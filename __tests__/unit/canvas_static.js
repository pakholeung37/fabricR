// var emptyImageCanvasData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAH7ElEQVR4nO3VMQ0AMAzAsPInvYHoMS2yEeTLHADge/M6AADYM3QACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIMHQACDB0AAgwdAAIuMjH4b7osLFBAAAAAElFTkSuQmCC";

var CANVAS_SVG =
  '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="200" height="200" viewBox="0 0 200 200" xml:space="preserve">\n<desc>Created with Fabric.js ' +
  fabric.version +
  "</desc>\n<defs>\n</defs>\n</svg>"

var CANVAS_SVG_VIEWBOX =
  '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="200" height="200" viewBox="100 100 300 300" xml:space="preserve">\n<desc>Created with Fabric.js ' +
  fabric.version +
  "</desc>\n<defs>\n</defs>\n</svg>"

var PATH_JSON =
  '{"version":"' +
  fabric.version +
  '","objects": [{"type": "path", "version":"' +
  fabric.version +
  '", "originX": "left", "originY": "top", "left": 268, "top": 266, "width": 51, "height": 49,' +
  ' "fill": "rgb(0,0,0)", "stroke": null, "strokeWidth": 1, "scaleX": 1, "scaleY": 1, ' +
  '"angle": 0, "flipX": false, "flipY": false, "opacity": 1, "path": [["M", 18.511, 13.99],' +
  ' ["c", 0, 0, -2.269, -4.487, -12.643, 4.411], ["c", 0, 0, 4.824, -14.161, 19.222, -9.059],' +
  ' ["l", 0.379, -2.1], ["c", -0.759, -0.405, -1.375, -1.139, -1.645, -2.117], ["c", -0.531, ' +
  '-1.864, 0.371, -3.854, 1.999, -4.453], ["c", 0.312, -0.118, 0.633, -0.169, 0.953, -0.169], ' +
  '["c", 1.299, 0, 2.514, 0.953, 2.936, 2.455], ["c", 0.522, 1.864, -0.372, 3.854, -1.999, ' +
  '4.453], ["c", -0.229, 0.084, -0.464, 0.127, -0.692, 0.152], ["l", -0.379, 2.37], ["c", ' +
  '1.146, 0.625, 2.024, 1.569, 2.674, 2.758], ["c", 3.213, 2.514, 8.561, 4.184, 11.774, -8.232],' +
  ' ["c", 0, 0, 0.86, 16.059, -12.424, 14.533], ["c", 0.008, 2.859, 0.615, 5.364, -0.076, 8.224],' +
  ' ["c", 8.679, 3.146, 15.376, 14.389, 17.897, 18.168], ["l", 2.497, -2.151], ["l", 1.206, 1.839],' +
  ' ["l", -3.889, 3.458], ["C", 46.286, 48.503, 31.036, 32.225, 22.72, 35.81], ["c", -1.307, 2.851,' +
  ' -3.56, 6.891, -7.481, 8.848], ["c", -4.689, 2.336, -9.084, -0.802, -11.277, -2.868], ["l",' +
  ' -1.948, 3.104], ["l", -1.628, -1.333], ["l", 3.138, -4.689], ["c", 0.025, 0, 9, 1.932, 9, 1.932], ' +
  '["c", 0.877, -9.979, 2.893, -12.905, 4.942, -15.621], ["C", 17.878, 21.775, 18.713, 17.397, 18.511, ' +
  '13.99], ["z"]]}], "background": "#ff5555", "overlay":"rgba(0,0,0,0.2)"}'

var PATH_WITHOUT_DEFAULTS_JSON =
  '{"version":"' +
  fabric.version +
  '","objects": [{"type": "path", "version":"' +
  fabric.version +
  '", "left": 268, "top": 266, "width": 51, "height": 49, "path": [["M", 18.511, 13.99],' +
  ' ["c", 0, 0, -2.269, -4.487, -12.643, 4.411], ["c", 0, 0, 4.824, -14.161, 19.222, -9.059],' +
  ' ["l", 0.379, -2.1], ["c", -0.759, -0.405, -1.375, -1.139, -1.645, -2.117], ["c", -0.531, ' +
  '-1.864, 0.371, -3.854, 1.999, -4.453], ["c", 0.312, -0.118, 0.633, -0.169, 0.953, -0.169], ' +
  '["c", 1.299, 0, 2.514, 0.953, 2.936, 2.455], ["c", 0.522, 1.864, -0.372, 3.854, -1.999, ' +
  '4.453], ["c", -0.229, 0.084, -0.464, 0.127, -0.692, 0.152], ["l", -0.379, 2.37], ["c", ' +
  '1.146, 0.625, 2.024, 1.569, 2.674, 2.758], ["c", 3.213, 2.514, 8.561, 4.184, 11.774, -8.232],' +
  ' ["c", 0, 0, 0.86, 16.059, -12.424, 14.533], ["c", 0.008, 2.859, 0.615, 5.364, -0.076, 8.224],' +
  ' ["c", 8.679, 3.146, 15.376, 14.389, 17.897, 18.168], ["l", 2.497, -2.151], ["l", 1.206, 1.839],' +
  ' ["l", -3.889, 3.458], ["C", 46.286, 48.503, 31.036, 32.225, 22.72, 35.81], ["c", -1.307, 2.851,' +
  ' -3.56, 6.891, -7.481, 8.848], ["c", -4.689, 2.336, -9.084, -0.802, -11.277, -2.868], ["l",' +
  ' -1.948, 3.104], ["l", -1.628, -1.333], ["l", 3.138, -4.689], ["c", 0.025, 0, 9, 1.932, 9, 1.932], ' +
  '["c", 0.877, -9.979, 2.893, -12.905, 4.942, -15.621], ["C", 17.878, 21.775, 18.713, 17.397, 18.511, ' +
  '13.99], ["z"]]}], "background": "#ff5555","overlay": "rgba(0,0,0,0.2)"}'

var PATH_DATALESS_JSON =
  '{"version":"' +
  fabric.version +
  '","objects":[{"type":"path","version":"' +
  fabric.version +
  '","originX":"left","originY":"top","left":99.5,"top":99.5,"width":200,"height":200,"fill":"rgb(0,0,0)",' +
  '"stroke":null,"strokeWidth":1,"strokeDashArray":null,"strokeLineCap":"butt","strokeDashOffset":0,"strokeLineJoin":"miter","strokeMiterLimit":4,' +
  '"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"opacity":1,' +
  '"shadow":null,"visible":true,"backgroundColor":"","fillRule":"nonzero","paintFirst":"fill","globalCompositeOperation":"source-over","skewX":0,"skewY":0,"sourcePath":"http://example.com/"}]}'

var RECT_JSON =
  '{"version":"' +
  fabric.version +
  '","objects":[{"type":"rect","version":"' +
  fabric.version +
  '","originX":"left","originY":"top","left":0,"top":0,"width":10,"height":10,"fill":"rgb(0,0,0)",' +
  '"stroke":null,"strokeWidth":1,"strokeDashArray":null,"strokeLineCap":"butt","strokeDashOffset":0,"strokeLineJoin":"miter","strokeMiterLimit":4,' +
  '"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"opacity":1,' +
  '"shadow":null,"visible":true,"backgroundColor":"","fillRule":"nonzero","paintFirst":"fill","globalCompositeOperation":"source-over","skewX":0,"skewY":0,"rx":0,"ry":0}],"background":"#ff5555","overlay":"rgba(0,0,0,0.2)"}'

var RECT_JSON_WITH_PADDING =
  '{"version":"' +
  fabric.version +
  '","objects":[{"type":"rect","version":"' +
  fabric.version +
  '","originX":"left","originY":"top","left":0,"top":0,"width":10,"height":20,"fill":"rgb(0,0,0)",' +
  '"stroke":null,"strokeWidth":1,"strokeDashArray":null,"strokeLineCap":"butt","strokeDashOffset":0,"strokeLineJoin":"miter","strokeMiterLimit":4,' +
  '"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"opacity":1,' +
  '"shadow":null,"visible":true,"backgroundColor":"","fillRule":"nonzero","paintFirst":"fill","globalCompositeOperation":"source-over","skewX":0,"skewY":0,"rx":0,"ry":0,"padding":123,"foo":"bar"}]}'

function getAbsolutePath(path) {
  var isAbsolute = /^https?:/.test(path)
  if (isAbsolute) {
    return path
  }
  var imgEl = _createImageElement()
  imgEl.src = path
  var src = imgEl.src
  imgEl = null
  return src
}
var IMG_SRC = fabric.isLikelyNode
    ? `file://${isWin ? "/" : ""}${path.posix.join(
        __dirname.replace(/\\/g, "/"),
        "/../fixtures/test_image.gif"
      )}`
    : getAbsolutePath("../fixtures/test_image.gif"),
  IMG_WIDTH = 276,
  IMG_HEIGHT = 110

var REFERENCE_IMG_OBJECT = {
  version: fabric.version,
  type: "image",
  originX: "left",
  originY: "top",
  left: 0,
  top: 0,
  width: IMG_WIDTH, // node-canvas doesn't seem to allow setting width/height on image objects
  height: IMG_HEIGHT, // or does it now?
  fill: "rgb(0,0,0)",
  stroke: null,
  strokeWidth: 0,
  strokeDashArray: null,
  strokeDashOffset: 0,
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  strokeMiterLimit: 4,
  scaleX: 1,
  scaleY: 1,
  angle: 0,
  flipX: false,
  flipY: false,
  opacity: 1,
  src: IMG_SRC,
  shadow: null,
  visible: true,
  backgroundColor: "",
  filters: [],
  fillRule: "nonzero",
  paintFirst: "fill",
  globalCompositeOperation: "source-over",
  crossOrigin: null,
  skewX: 0,
  skewY: 0,
  cropX: 0,
  cropY: 0
}

function _createImageElement() {
  return fabric.document.createElement("img")
}

function _createImageObject(width, height, callback) {
  var elImage = _createImageElement()
  elImage.width = width
  elImage.height = height
  setSrc(elImage, IMG_SRC, function () {
    callback(new fabric.Image(elImage))
  })
}

function createImageObject(callback) {
  return _createImageObject(IMG_WIDTH, IMG_HEIGHT, callback)
}

function setSrc(img, src, callback) {
  img.onload = callback
  img.src = src
}

function fixImageDimension(imgObj) {
  // workaround for node-canvas sometimes producing images with width/height and sometimes not
  if (imgObj.width === 0) {
    imgObj.width = IMG_WIDTH
  }
  if (imgObj.height === 0) {
    imgObj.height = IMG_HEIGHT
  }
}

// force creation of static canvas
// TODO: fix this
var canvas = new fabric.StaticCanvas(null, {
  renderOnAddRemove: false,
  enableRetinaScaling: false,
  width: 200,
  height: 200
})
var canvas2 = new fabric.StaticCanvas(null, {
  renderOnAddRemove: false,
  enableRetinaScaling: false,
  width: 200,
  height: 200
})

var lowerCanvasEl = canvas.lowerCanvasEl

function makeRect(options) {
  var defaultOptions = { width: 10, height: 10 }
  return new fabric.Rect(
    fabric.util.object.extend(defaultOptions, options || {})
  )
}

describe("fabric.StaticCanvas", () => {
  beforeEach(function () {
    fabric.Object.__uid = 0
    canvas.clear()
    canvas.setDimensions({ width: 200, heigth: 200 })
    canvas2.setDimensions({ width: 200, heigth: 200 })
    canvas.backgroundColor = fabric.StaticCanvas.prototype.backgroundColor
    canvas.backgroundImage = fabric.StaticCanvas.prototype.backgroundImage
    canvas.overlayColor = fabric.StaticCanvas.prototype.overlayColor
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    canvas.calcOffset()
    canvas.cancelRequestedRender()
    canvas2.cancelRequestedRender()
  })
  afterEach(function () {
    canvas.cancelRequestedRender()
    canvas2.cancelRequestedRender()
  })
  test("initialProperties", function () {
    var canvas = new fabric.StaticCanvas()
    expect("backgroundColor" in canvas).toBeTruthy()
    expect("overlayColor" in canvas).toBeTruthy()
    expect("backgroundImage" in canvas).toBeTruthy()
    expect("overlayImage" in canvas).toBeTruthy()
    expect("includeDefaultValues" in canvas).toBeTruthy()
    expect("stateful" in canvas).toBeTruthy()
    expect("renderOnAddRemove" in canvas).toBeTruthy()
    expect("controlsAboveOverlay" in canvas).toBeTruthy()
    expect("allowTouchScrolling" in canvas).toBeTruthy()
    expect("imageSmoothingEnabled" in canvas).toBeTruthy()
    expect("backgroundVpt" in canvas).toBeTruthy()
    expect("overlayVpt" in canvas).toBeTruthy()

    expect(canvas.includeDefaultValues).toEqual(true)
    expect(canvas.stateful).toEqual(false)
    expect(canvas.renderOnAddRemove).toEqual(true)
    expect(canvas.controlsAboveOverlay).toEqual(false)
    expect(canvas.allowTouchScrolling).toEqual(false)
    expect(canvas.imageSmoothingEnabled).toEqual(true)
    expect(canvas.backgroundVpt).toEqual(true)
    expect(canvas.overlayVpt).toEqual(true)

    expect(canvas.viewportTransform).not.toBe(canvas2.viewportTransform)
  })

  test("getObjects", function () {
    expect(typeof canvas.getObjects === "function").toBeTruthy()
    expect([]).toEqual(canvas.getObjects())
    expect(canvas.getObjects().length).toEqual(0)
  })

  test("getObjects with type", function () {
    var rect = new fabric.Rect({ width: 10, height: 20 })
    var circle = new fabric.Circle({ radius: 30 })

    canvas.add(rect, circle)

    expect(canvas.getObjects().length).toEqual(2)

    expect(canvas.getObjects("rect")).toEqual([rect])
    expect(canvas.getObjects("circle")).toEqual([circle])
  })

  test("getElement", function () {
    expect(typeof canvas.getElement === "function").toBeTruthy()
    expect(canvas.getElement()).toEqual(lowerCanvasEl)
  })

  test("item", function () {
    var rect = makeRect()

    expect(typeof canvas.item === "function").toBeTruthy()
    canvas.add(rect)
    expect(canvas.item(0)).toEqual(rect)
  })

  test("calcOffset", function () {
    expect(typeof canvas.calcOffset === "function").toBeTruthy()
    expect(canvas.calcOffset()).toEqual(canvas)
  })

  test("add", function () {
    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect(),
      rect4 = makeRect()

    expect(typeof canvas.add === "function").toBeTruthy()
    expect(canvas.add(rect1)).toEqual(canvas)
    expect(canvas.item(0)).toBe(rect1)

    canvas.add(rect2, rect3, rect4)
    expect(canvas.getObjects().length).toEqual(4)

    expect(canvas.item(1)).toBe(rect2)
    expect(canvas.item(2)).toBe(rect3)
    expect(canvas.item(3)).toBe(rect4)
  })

  test("add renderOnAddRemove disabled", function () {
    var rect = makeRect(),
      originalRenderOnAddition,
      renderAllCount = 0

    function countRenderAll() {
      renderAllCount++
    }

    originalRenderOnAddition = canvas.renderOnAddRemove
    canvas.renderOnAddRemove = false

    canvas.on("after:render", countRenderAll)

    expect(canvas.add(rect)).toEqual(canvas)
    expect(renderAllCount).toEqual(0)

    expect(canvas.item(0)).toEqual(rect)

    canvas.add(makeRect(), makeRect(), makeRect())
    expect(canvas.getObjects().length).toEqual(4)
    expect(renderAllCount).toEqual(0)

    canvas.renderAll()
    expect(renderAllCount).toEqual(1)

    canvas.off("after:render", countRenderAll)
    canvas.renderOnAddRemove = originalRenderOnAddition
  })

  test("object:added", function () {
    var objectsAdded = []

    canvas.on("object:added", function (e) {
      objectsAdded.push(e.target)
    })

    var rect = new fabric.Rect({ width: 10, height: 20 })
    canvas.add(rect)

    expect(objectsAdded[0]).toEqual(rect)

    var circle1 = new fabric.Circle(),
      circle2 = new fabric.Circle()

    canvas.add(circle1, circle2)

    expect(objectsAdded[1]).toBe(circle1)
    expect(objectsAdded[2]).toBe(circle2)

    var circle3 = new fabric.Circle()
    canvas.insertAt(circle3, 2)

    expect(objectsAdded[3]).toBe(circle3)
  })

  test("insertAt", function () {
    var rect1 = makeRect(),
      rect2 = makeRect()

    canvas.add(rect1, rect2)

    expect(typeof canvas.insertAt === "function").toBeTruthy()

    var rect = makeRect()
    canvas.insertAt(rect, 1)
    expect(canvas.item(1)).toBe(rect)
    canvas.insertAt(rect, 2)
    expect(canvas.item(2)).toBe(rect)
    expect(canvas.insertAt(rect, 2)).toEqual(canvas)
  })

  test("insertAt renderOnAddRemove disabled", function () {
    var rect1 = makeRect(),
      rect2 = makeRect(),
      originalRenderOnAddition,
      renderAllCount = 0

    function countRenderAll() {
      renderAllCount++
    }

    originalRenderOnAddition = canvas.renderOnAddRemove
    canvas.renderOnAddRemove = false

    canvas.on("after:render", countRenderAll)

    canvas.add(rect1, rect2)
    expect(renderAllCount).toEqual(0)

    var rect = makeRect()

    canvas.insertAt(rect, 1)
    expect(renderAllCount).toEqual(0)

    expect(canvas.item(1)).toBe(rect)
    canvas.insertAt(rect, 2)
    expect(renderAllCount).toEqual(0)

    canvas.renderAll()
    expect(renderAllCount).toEqual(1)

    canvas.off("after:render", countRenderAll)
    canvas.renderOnAddRemove = originalRenderOnAddition
  })

  test("remove", function () {
    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect(),
      rect4 = makeRect()

    canvas.add(rect1, rect2, rect3, rect4)

    expect(typeof canvas.remove === "function").toBeTruthy()
    expect(canvas.remove(rect1)).toEqual(canvas)
    expect(canvas.item(0)).toBe(rect2)

    canvas.remove(rect2, rect3)
    expect(canvas.item(0)).toBe(rect4)

    canvas.remove(rect4)
    expect(canvas.isEmpty()).toEqual(true)
  })

  test("remove renderOnAddRemove disabled", function () {
    var rect1 = makeRect(),
      rect2 = makeRect(),
      originalRenderOnAddition,
      renderAllCount = 0

    function countRenderAll() {
      renderAllCount++
    }

    originalRenderOnAddition = canvas.renderOnAddRemove
    canvas.renderOnAddRemove = false

    canvas.on("after:render", countRenderAll)

    canvas.add(rect1, rect2)
    expect(renderAllCount).toEqual(0)

    expect(canvas.remove(rect1)).toEqual(canvas)
    expect(renderAllCount).toEqual(0)
    expect(canvas.item(0)).toBe(rect2)

    canvas.renderAll()
    expect(renderAllCount).toEqual(1)

    canvas.off("after:render", countRenderAll)
    canvas.renderOnAddRemove = originalRenderOnAddition
  })

  test("object:removed", function () {
    var objectsRemoved = []

    canvas.on("object:removed", function (e) {
      objectsRemoved.push(e.target)
    })

    var rect = new fabric.Rect({ width: 10, height: 20 }),
      circle1 = new fabric.Circle(),
      circle2 = new fabric.Circle()

    canvas.add(rect, circle1, circle2)

    expect(canvas.item(0)).toBe(rect)
    expect(canvas.item(1)).toBe(circle1)
    expect(canvas.item(2)).toBe(circle2)

    canvas.remove(rect)
    expect(objectsRemoved[0]).toBe(rect)

    canvas.remove(circle1, circle2)
    expect(objectsRemoved[1]).toBe(circle1)
    expect(objectsRemoved[2]).toBe(circle2)

    expect(canvas.isEmpty()).toEqual(true)
  })

  test("clearContext", function () {
    expect(typeof canvas.clearContext === "function").toBeTruthy()
    expect(canvas.clearContext(canvas.contextContainer)).toEqual(canvas)
  })

  test("clear", function () {
    expect(typeof canvas.clear === "function").toBeTruthy()
    var bg = new fabric.Rect({ width: 10, height: 20 })
    canvas.backgroundColor = "#FF0000"
    canvas.overlayColor = "#FF0000"
    canvas.backgroundImage = bg
    canvas.overlayImage = bg
    expect(canvas.clear()).toEqual(canvas)
    expect(canvas.getObjects().length).toEqual(0)
    expect(canvas.backgroundColor).toEqual("")
    expect(canvas.overlayColor).toEqual("")
    expect(canvas.backgroundImage).toEqual(null)
    expect(canvas.overlayImage).toEqual(null)
  })

  test("renderAll", function () {
    expect(typeof canvas.renderAll === "function").toBeTruthy()
    expect(canvas).toEqual(canvas.renderAll())
  })

  // test('setDimensions', function(done) {
  //   done.ok(typeof canvas.setDimensions === 'function');;
  //   canvas.setDimensions({ width: 4, height: 5 });
  //   done.equal(canvas.getWidth(), 4);
  //   done.equal(canvas.getHeight(), 5);
  //   done.equal(canvas.lowerCanvasEl.style.width, '5px');
  //   done.equal(canvas.lowerCanvasEl.style.height, '4px');
  // });

  test("toCanvasElement", function () {
    expect(typeof canvas.toCanvasElement === "function").toBeTruthy()
    var canvasEl = canvas.toCanvasElement()
    expect(canvasEl.width).toEqual(canvas.getWidth())
    expect(canvasEl.height).toEqual(canvas.getHeight())
  })

  test("toCanvasElement with multiplier", function () {
    expect(typeof canvas.toCanvasElement === "function").toBeTruthy()
    var multiplier = 2
    var canvasEl = canvas.toCanvasElement(multiplier)
    expect(canvasEl.width).toEqual(canvas.getWidth() * multiplier)
    expect(canvasEl.height).toEqual(canvas.getHeight() * multiplier)
  })

  test("toDataURL", function () {
    expect(typeof canvas.toDataURL === "function").toBeTruthy()
    var rect = new fabric.Rect({
      width: 100,
      height: 100,
      fill: "red",
      top: 0,
      left: 0
    })
    canvas.add(rect)
    var dataURL = canvas.toDataURL()
    // don't compare actual data url, as it is often browser-dependent
    // this.doneIdentical(emptyImageCanvasData, canvas.toDataURL('png'));
    expect(typeof dataURL).toEqual("string")
    expect(dataURL.substring(0, 21)).toEqual("data:image/png;base64")
    //we can just compare that the dataUrl generated differs from the dataURl of an empty canvas.
    expect(dataURL.substring(200, 210) !== "AAAAAAAAAA").toEqual(true)
  })

  test("toDataURL with enableRetinaScaling: true and no multiplier", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: true })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width * fabric.devicePixelRatio)
      expect(img.height).toEqual(c.height * fabric.devicePixelRatio)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: true and multiplier = 1", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: true, multiplier: 1 })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width * fabric.devicePixelRatio)
      expect(img.height).toEqual(c.height * fabric.devicePixelRatio)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: true and multiplier = 3", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: true, multiplier: 3 })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width * fabric.devicePixelRatio * 3)
      expect(img.height).toEqual(c.height * fabric.devicePixelRatio * 3)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: false and no multiplier", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: false })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width)
      expect(img.height).toEqual(c.height)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: false and multiplier = 1", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: false, multiplier: 1 })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width)
      expect(img.height).toEqual(c.height)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: false and multiplier = 3", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: false, multiplier: 3 })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width * 3)
      expect(img.height).toEqual(c.height * 3)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL with enableRetinaScaling: false", function (done) {
    fabric.devicePixelRatio = 2
    var c = new fabric.StaticCanvas(null, {
      enableRetinaScaling: true,
      width: 10,
      height: 10
    })
    var dataUrl = c.toDataURL({ enableRetinaScaling: false })
    c.cancelRequestedRender()
    var img = fabric.document.createElement("img")
    img.onload = function () {
      expect(img.width).toEqual(c.width)
      expect(img.height).toEqual(c.height)
      fabric.devicePixelRatio = 1
      done()
    }
    img.src = dataUrl
  })

  test("toDataURL jpeg", function () {
    try {
      var dataURL = canvas.toDataURL({ format: "jpeg" })
      expect(dataURL.substring(0, 22)).toEqual("data:image/jpeg;base64")
    } catch (err) {
      // node-canvas does not support jpeg data urls
      expect(true).toBeTruthy()
    }
  })

  test("toDataURL cropping", function (done) {
    expect(typeof canvas.toDataURL === "function").toBeTruthy()
    var croppingWidth = 75,
      croppingHeight = 50,
      dataURL = canvas.toDataURL({
        width: croppingWidth,
        height: croppingHeight
      })

    fabric.Image.fromURL(dataURL, function (img) {
      expect(img.width).toEqual(croppingWidth)
      expect(img.height).toEqual(croppingHeight)
      done()
    })
  })

  test("centerObjectH", function () {
    expect(typeof canvas.centerObjectH === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 })
    canvas.add(rect)
    expect(canvas.centerObjectH(rect)).toEqual(canvas)
    expect(rect.getCenterPoint().x).toEqual(canvas.width / 2)
    canvas.setZoom(4)
    expect(rect.getCenterPoint().x).toEqual(canvas.height / 2)
    canvas.setZoom(1)
  })

  test("centerObjectV", function () {
    expect(typeof canvas.centerObjectV === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 })
    canvas.add(rect)
    expect(canvas.centerObjectV(rect)).toEqual(canvas)
    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
    canvas.setZoom(2)
    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
  })

  test("centerObject", function () {
    expect(typeof canvas.centerObject === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 })
    canvas.add(rect)
    expect(canvas.centerObject(rect)).toEqual(canvas)

    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
    expect(rect.getCenterPoint().x).toEqual(canvas.height / 2)
    canvas.setZoom(4)
    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
    expect(rect.getCenterPoint().x).toEqual(canvas.height / 2)
    canvas.setZoom(1)
  })

  test("viewportCenterObjectH", function () {
    expect(typeof canvas.viewportCenterObjectH === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 }),
      pan = 10
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    canvas.add(rect)
    var oldY = rect.top
    expect(canvas.viewportCenterObjectH(rect)).toEqual(canvas)
    expect(rect.getCenterPoint().x).toEqual(canvas.width / 2)
    expect(rect.top).toEqual(oldY)
    canvas.setZoom(2)
    canvas.viewportCenterObjectH(rect)
    expect(rect.getCenterPoint().x).toEqual(
      canvas.width / (2 * canvas.getZoom())
    )
    expect(rect.top).toEqual(oldY)
    canvas.absolutePan({ x: pan, y: pan })
    canvas.viewportCenterObjectH(rect)
    expect(rect.getCenterPoint().x).toEqual(
      (canvas.width / 2 + pan) / canvas.getZoom()
    )
    expect(rect.top).toEqual(oldY)
  })

  test("viewportCenterObjectV", function () {
    expect(typeof canvas.viewportCenterObjectV === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 }),
      pan = 10
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    canvas.add(rect)
    var oldX = rect.left
    expect(canvas.viewportCenterObjectV(rect)).toEqual(canvas)
    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
    expect(rect.left).toEqual(oldX)
    canvas.setZoom(2)
    canvas.viewportCenterObjectV(rect)
    expect(rect.getCenterPoint().y).toEqual(
      canvas.height / (2 * canvas.getZoom())
    )
    expect(rect.left).toEqual(oldX)
    canvas.absolutePan({ x: pan, y: pan })
    canvas.viewportCenterObjectV(rect)
    expect(rect.getCenterPoint().y).toEqual(
      (canvas.height / 2 + pan) / canvas.getZoom()
    )
    expect(rect.left).toEqual(oldX)
  })

  test("viewportCenterObject", function () {
    expect(typeof canvas.viewportCenterObject === "function").toBeTruthy()
    var rect = makeRect({ left: 102, top: 202 }),
      pan = 10
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    canvas.add(rect)
    expect(canvas.viewportCenterObject(rect)).toEqual(canvas)
    expect(rect.getCenterPoint().y).toEqual(canvas.height / 2)
    expect(rect.getCenterPoint().x).toEqual(canvas.width / 2)

    canvas.setZoom(2)
    canvas.viewportCenterObject(rect)
    expect(rect.getCenterPoint().y).toEqual(
      canvas.height / (2 * canvas.getZoom())
    )
    expect(rect.getCenterPoint().x).toEqual(
      canvas.width / (2 * canvas.getZoom())
    )

    canvas.absolutePan({ x: pan, y: pan })
    canvas.viewportCenterObject(rect)
    expect(rect.getCenterPoint().y).toEqual(
      (canvas.height / 2 + pan) / canvas.getZoom()
    )
    expect(rect.getCenterPoint().x).toEqual(
      (canvas.width / 2 + pan) / canvas.getZoom()
    )
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
  })

  test("straightenObject", function () {
    expect(typeof canvas.straightenObject === "function").toBeTruthy()
    var rect = makeRect({ angle: 10 })
    canvas.add(rect)
    expect(canvas.straightenObject(rect)).toEqual(canvas)
    expect(rect.get("angle")).toEqual(0)

    rect.rotate("60")
    canvas.straightenObject(rect)
    expect(rect.get("angle")).toEqual(90)

    rect.rotate("100")
    canvas.straightenObject(rect)
    expect(rect.get("angle")).toEqual(90)
  })

  test("toSVG", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    var svg = canvas.toSVG()
    expect(svg).toEqual(CANVAS_SVG)
  })

  test("toSVG with different encoding (ISO-8859-1)", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0]
    var svg = canvas.toSVG({ encoding: "ISO-8859-1" })
    var svgDefaultEncoding = canvas.toSVG()
    expect(svg != svgDefaultEncoding).toBeTruthy()
    expect(svg).toEqual(
      CANVAS_SVG.replace('encoding="UTF-8"', 'encoding="ISO-8859-1"')
    )
  })

  test("toSVG without preamble", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    var withPreamble = canvas.toSVG()
    var withoutPreamble = canvas.toSVG({ suppressPreamble: true })
    expect(withPreamble != withoutPreamble).toBeTruthy()
    expect(withoutPreamble.slice(0, 4)).toEqual("<svg")
  })

  test("toSVG with viewBox", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()

    var svg = canvas.toSVG({
      viewBox: { x: 100, y: 100, width: 300, height: 300 }
    })
    expect(svg).toEqual(CANVAS_SVG_VIEWBOX)
  })

  test("toSVG with reviver", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()

    var circle = new fabric.Circle(),
      rect = new fabric.Rect(),
      path1 = new fabric.Path("M 100 100 L 300 100 L 200 300 z"),
      tria = new fabric.Triangle(),
      polygon = new fabric.Polygon([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      polyline = new fabric.Polyline([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      line = new fabric.Line(),
      text = new fabric.Text("Text"),
      group = new fabric.Group([text, line]),
      ellipse = new fabric.Ellipse(),
      image = new fabric.Image({ width: 0, height: 0 }),
      path2 = new fabric.Path("M 0 0 L 200 100 L 200 300 z"),
      path3 = new fabric.Path("M 50 50 L 100 300 L 400 400 z"),
      pathGroup = new fabric.Group([path2, path3])

    canvas.renderOnAddRemove = false
    canvas.add(
      circle,
      rect,
      path1,
      tria,
      polygon,
      polyline,
      group,
      ellipse,
      image,
      pathGroup
    )

    var reviverCount = 0

    function reviver(svg) {
      reviverCount++
      return svg
    }

    canvas.toSVG(null, reviver)
    expect(reviverCount).toEqual(14)

    canvas.renderOnAddRemove = true
  })

  test("toSVG with reviver 2", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()

    var circle = new fabric.Circle(),
      rect = new fabric.Rect(),
      path1 = new fabric.Path("M 100 100 L 300 100 L 200 300 z"),
      tria = new fabric.Triangle(),
      polygon = new fabric.Polygon([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      polyline = new fabric.Polyline([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      line = new fabric.Line(),
      text = new fabric.Text("Text"),
      group = new fabric.Group([text, line]),
      ellipse = new fabric.Ellipse(),
      image = new fabric.Image({ width: 0, height: 0 }),
      imageBG = new fabric.Image({ width: 0, height: 0 }),
      imageOL = new fabric.Image({ width: 0, height: 0 }),
      path2 = new fabric.Path("M 0 0 L 200 100 L 200 300 z"),
      path3 = new fabric.Path("M 50 50 L 100 300 L 400 400 z"),
      pathGroup = new fabric.Group([path2, path3])

    canvas.renderOnAddRemove = false
    canvas.add(
      circle,
      rect,
      path1,
      tria,
      polygon,
      polyline,
      group,
      ellipse,
      image,
      pathGroup
    )
    canvas.setBackgroundImage(imageBG)
    canvas.setOverlayImage(imageOL)
    var reviverCount = 0,
      len = canvas.size() + group.size() + pathGroup.size()

    function reviver(svg) {
      reviverCount++
      return svg
    }

    canvas.toSVG(null, reviver)
    expect(reviverCount).toEqual(len + 2)
    canvas.setBackgroundImage(null)
    canvas.setOverlayImage(null)
    canvas.renderOnAddRemove = true
  })

  test("toSVG with exclude from export", function () {
    expect(typeof canvas.toSVG === "function").toBeTruthy()
    canvas.clear()

    var circle = new fabric.Circle({ excludeFromExport: true }),
      rect = new fabric.Rect({ excludeFromExport: true }),
      path1 = new fabric.Path("M 100 100 L 300 100 L 200 300 z"),
      tria = new fabric.Triangle(),
      polygon = new fabric.Polygon([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      polyline = new fabric.Polyline([
        { x: 10, y: 12 },
        { x: 20, y: 22 }
      ]),
      line = new fabric.Line(),
      text = new fabric.Text("Text"),
      group = new fabric.Group([text, line]),
      ellipse = new fabric.Ellipse(),
      image = new fabric.Image({ width: 0, height: 0 }),
      path2 = new fabric.Path("M 0 0 L 200 100 L 200 300 z"),
      path3 = new fabric.Path("M 50 50 L 100 300 L 400 400 z"),
      pathGroup = new fabric.Group([path2, path3])

    canvas.renderOnAddRemove = false
    canvas.add(
      circle,
      rect,
      path1,
      tria,
      polygon,
      polyline,
      group,
      ellipse,
      image,
      pathGroup
    )
    var reviverCount = 0,
      len = canvas.size() + group.size() + pathGroup.size()

    function reviver(svg) {
      reviverCount++
      return svg
    }

    canvas.toSVG(null, reviver)
    expect(reviverCount).toEqual(len - 2)
    canvas.renderOnAddRemove = true
  })

  test("toSVG with a clipPath", function () {
    var canvasClip = new fabric.StaticCanvas(null, {
      width: 400,
      height: 400,
      renderOnAddRemove: false
    })
    canvasClip.clipPath = new fabric.Rect({ width: 200, height: 200 })
    canvasClip.add(new fabric.Circle({ radius: 200 }))
    var svg = canvasClip.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="400" height="400" viewBox="0 0 400 400" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n<clipPath id="CLIPPATH_0" >\n\t<rect transform="matrix(1 0 0 1 100.5 100.5)" x="-100" y="-100" rx="0" ry="0" width="200" height="200" />\n</clipPath>\n</defs>\n<g clip-path="url(#CLIPPATH_0)" >\n<g transform="matrix(1 0 0 1 200.5 200.5)"  >\n<circle style="stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  cx="0" cy="0" r="200" />\n</g>\n</g>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("toSVG with exclude from export background", function () {
    var image = fabric.document.createElement("img"),
      imageBG = new fabric.Image(image, { width: 0, height: 0 }),
      imageOL = new fabric.Image(image, { width: 0, height: 0 })

    canvas.renderOnAddRemove = false
    canvas.backgroundImage = imageBG
    canvas.overlayImage = imageOL
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="200" height="200" viewBox="0 0 200 200" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n</defs>\n<g transform="matrix(1 0 0 1 0 0)"  >\n\t<image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  xlink:href="" x="0" y="0" width="0" height="0"></image>\n</g>\n<g transform="matrix(1 0 0 1 0 0)"  >\n\t<image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  xlink:href="" x="0" y="0" width="0" height="0"></image>\n</g>\n</svg>'
    var svg1 = canvas.toSVG()
    expect(svg1).toEqual(expectedSVG)
    imageBG.excludeFromExport = true
    imageOL.excludeFromExport = true
    var expectedSVG2 =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="200" height="200" viewBox="0 0 200 200" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      "</desc>\n<defs>\n</defs>\n</svg>"
    var svg2 = canvas.toSVG()
    expect(svg2).toEqual(expectedSVG2)
    canvas.backgroundImage = null
    canvas.overlayImage = null
    canvas.renderOnAddRemove = true
  })

  test("toJSON", function () {
    expect(typeof canvas.toJSON === "function").toBeTruthy()
    expect(JSON.stringify(canvas.toJSON())).toEqual(
      '{"version":"' + fabric.version + '","objects":[]}'
    )
    canvas.backgroundColor = "#ff5555"
    canvas.overlayColor = "rgba(0,0,0,0.2)"
    expect(JSON.stringify(canvas.toJSON())).toEqual(
      '{"version":"' +
        fabric.version +
        '","objects":[],"background":"#ff5555","overlay":"rgba(0,0,0,0.2)"}'
    )
    canvas.add(makeRect())
    expect(JSON.stringify(canvas.toJSON())).toEqual(RECT_JSON)
  })

  test("toJSON custom properties non-existence check", function () {
    var rect = new fabric.Rect({ width: 10, height: 20 })
    rect.padding = 123
    canvas.add(rect)
    rect.foo = "bar"

    canvas.bar = 456

    var data = canvas.toJSON(["padding", "foo", "bar", "baz"])
    expect("padding" in data.objects[0]).toBeTruthy()
    expect("foo" in data.objects[0]).toBeTruthy()
    expect(!("bar" in data.objects[0])).toBeTruthy()
    expect(!("baz" in data.objects[0])).toBeTruthy()
    expect(!("foo" in data)).toBeTruthy()
    expect(!("baz" in data)).toBeTruthy()
    expect("bar" in data).toBeTruthy()
  })

  test("toJSON backgroundImage", function (done) {
    createImageObject(function (image) {
      canvas.backgroundImage = image

      var json = canvas.toJSON()

      fixImageDimension(json.backgroundImage)
      expect(json.backgroundImage).toEqual(REFERENCE_IMG_OBJECT)

      canvas.backgroundImage = null

      done()
    })
  })

  test("toJSON backgroundImage with custom props", function (done) {
    createImageObject(function (image) {
      canvas.backgroundImage = image
      image.custom = "yes"
      var json = canvas.toJSON(["custom"])
      expect(json.backgroundImage.custom).toEqual("yes")
      canvas.backgroundImage = null
      done()
    })
  })

  test("toJSON overlayImage", function (done) {
    createImageObject(function (image) {
      canvas.overlayImage = image

      var json = canvas.toJSON()

      fixImageDimension(json.overlayImage)
      expect(json.overlayImage).toEqual(REFERENCE_IMG_OBJECT)

      canvas.overlayImage = null

      done()
    })
  })

  test("toJSON overlayImage with custom props", function (done) {
    createImageObject(function (image) {
      canvas.overlayImage = image
      image.custom = "yes"
      var json = canvas.toJSON(["custom"])
      expect(json.overlayImage.custom).toEqual("yes")
      canvas.overlayImage = null
      done()
    })
  })

  test("toDatalessJSON", function () {
    var path = new fabric.Path("M 100 100 L 300 100 L 200 300 z", {
      sourcePath: "http://example.com/"
    })
    canvas.add(path)
    expect(JSON.stringify(canvas.toDatalessJSON())).toEqual(PATH_DATALESS_JSON)
  })

  test("toObject", function () {
    expect(typeof canvas.toObject === "function").toBeTruthy()
    var expectedObject = {
      version: fabric.version,
      objects: canvas.getObjects()
    }
    expect(expectedObject).toEqual(canvas.toObject())

    var rect = makeRect()
    canvas.add(rect)

    expect(canvas.toObject().objects[0].type).toEqual(rect.type)
  })

  test("toObject non includeDefaultValues", function () {
    canvas.includeDefaultValues = false
    var rect = makeRect()
    canvas.add(rect)
    var cObject = canvas.toObject()
    var expectedRect = {
      version: fabric.version,
      type: "rect",
      width: 10,
      height: 10,
      top: 0,
      left: 0
    }
    expect(cObject.objects[0]).toEqual(expectedRect)
    canvas.includeDefaultValues = true
  })

  test("toObject excludeFromExport", function () {
    var rect = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()
    canvas.clear()
    canvas.add(rect, rect2, rect3)
    expect(canvas.toObject().objects.length).toEqual(3)
    rect.excludeFromExport = true
    rect2.excludeFromExport = true
    expect(canvas.toObject().objects.length).toEqual(1)
  })

  test("toObject excludeFromExport bgImage overlay", function () {
    var rect = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()
    canvas.clear()
    canvas.backgroundImage = rect
    canvas.overlayImage = rect2
    canvas.add(rect3)
    var rectToObject = rect.toObject()
    var rect2ToObject = rect2.toObject()
    var canvasToObject = canvas.toObject()
    expect(canvasToObject.backgroundImage).toEqual(rectToObject)
    expect(canvasToObject.overlayImage).toEqual(rect2ToObject)
    rect.excludeFromExport = true
    rect2.excludeFromExport = true
    canvasToObject = canvas.toObject()
    expect(canvasToObject.backgroundImage).toEqual(undefined)
    expect(canvasToObject.overlayImage).toEqual(undefined)
  })

  test("toDatalessObject", function () {
    expect(typeof canvas.toDatalessObject === "function").toBeTruthy()
    var expectedObject = {
      version: fabric.version,
      objects: canvas.getObjects()
    }
    expect(expectedObject).toEqual(canvas.toDatalessObject())

    var rect = makeRect()
    canvas.add(rect)

    expect(canvas.toObject().objects[0].type).toEqual(rect.type)
    // TODO (kangax): need to test this method with fabric.Path to ensure that path is not populated
  })

  test("toObject with additional properties", function () {
    canvas.freeDrawingColor = "red"
    canvas.foobar = 123

    var expectedObject = {
      version: fabric.version,
      objects: canvas.getObjects(),
      freeDrawingColor: "red",
      foobar: 123
    }
    expect(expectedObject).toEqual(
      canvas.toObject(["freeDrawingColor", "foobar"])
    )
    var rect = makeRect()
    rect.foobar = 456
    canvas.add(rect)

    expect(!("foobar" in canvas.toObject(["smthelse"]).objects[0])).toBeTruthy()
    expect("foobar" in canvas.toObject(["foobar"]).objects[0]).toBeTruthy()
  })

  test("isEmpty", function () {
    expect(typeof canvas.isEmpty === "function").toBeTruthy()
    expect(canvas.isEmpty()).toBeTruthy()
    canvas.add(makeRect())
    expect(!canvas.isEmpty()).toBeTruthy()
  })

  test("loadFromJSON with json string staticCanvas", function (done) {
    expect(typeof canvas.loadFromJSON === "function").toBeTruthy()

    canvas.loadFromJSON(PATH_JSON, function () {
      var obj = canvas.item(0)

      expect(!canvas.isEmpty()).toBeTruthy()
      expect(obj.type).toEqual("path")
      expect(canvas.backgroundColor).toEqual("#ff5555")

      expect(obj.get("left")).toEqual(268)
      expect(obj.get("top")).toEqual(266)
      expect(obj.get("width")).toEqual(49.803999999999995)
      expect(obj.get("height")).toEqual(48.027)
      expect(obj.get("fill")).toEqual("rgb(0,0,0)")
      expect(obj.get("stroke")).toBe(null)
      expect(obj.get("strokeWidth")).toBe(1)
      expect(obj.get("scaleX")).toBe(1)
      expect(obj.get("scaleY")).toBe(1)
      expect(obj.get("angle")).toBe(0)
      expect(obj.get("flipX")).toBe(false)
      expect(obj.get("flipY")).toBe(false)
      expect(obj.get("opacity")).toBe(1)
      expect(obj.get("path").length > 0).toBeTruthy()
      done()
    })
  })

  test("loadFromJSON with json object", function (done) {
    expect(typeof canvas.loadFromJSON === "function").toBeTruthy()

    canvas.loadFromJSON(JSON.parse(PATH_JSON), function () {
      var obj = canvas.item(0)

      expect(!canvas.isEmpty()).toBeTruthy()
      expect(obj.type).toEqual("path")
      expect(canvas.backgroundColor).toEqual("#ff5555")
      expect(canvas.overlayColor).toEqual("rgba(0,0,0,0.2)")

      expect(obj.get("left")).toEqual(268)
      expect(obj.get("top")).toEqual(266)
      expect(obj.get("width")).toEqual(49.803999999999995)
      expect(obj.get("height")).toEqual(48.027)
      expect(obj.get("fill")).toEqual("rgb(0,0,0)")
      expect(obj.get("stroke")).toBe(null)
      expect(obj.get("strokeWidth")).toBe(1)
      expect(obj.get("scaleX")).toBe(1)
      expect(obj.get("scaleY")).toBe(1)
      expect(obj.get("angle")).toBe(0)
      expect(obj.get("flipX")).toBe(false)
      expect(obj.get("flipY")).toBe(false)
      expect(obj.get("opacity")).toBe(1)

      expect(obj.get("path").length > 0).toBeTruthy()
      done()
    })
  })

  test("loadFromJSON with json object without default values", function (done) {
    expect(typeof canvas.loadFromJSON === "function").toBeTruthy()

    canvas.loadFromJSON(JSON.parse(PATH_WITHOUT_DEFAULTS_JSON), function () {
      var obj = canvas.item(0)

      expect(!canvas.isEmpty()).toBeTruthy()
      expect(obj.type).toEqual("path")
      expect(canvas.backgroundColor).toEqual("#ff5555")
      expect(canvas.overlayColor).toEqual("rgba(0,0,0,0.2)")

      expect(obj.get("left")).toEqual(268)
      expect(obj.get("top")).toEqual(266)
      expect(obj.get("width")).toEqual(49.803999999999995)
      expect(obj.get("height")).toEqual(48.027)
      expect(obj.get("fill")).toEqual("rgb(0,0,0)")
      expect(obj.get("stroke")).toBe(null)
      expect(obj.get("strokeWidth")).toBe(1)
      expect(obj.get("scaleX")).toBe(1)
      expect(obj.get("scaleY")).toBe(1)
      expect(obj.get("angle")).toBe(0)
      expect(obj.get("flipX")).toBe(false)
      expect(obj.get("flipY")).toBe(false)
      expect(obj.get("opacity")).toBe(1)

      expect(obj.get("path").length > 0).toBeTruthy()
      done()
    })
  })

  test("loadFromJSON with image background and color", function (done) {
    var serialized = JSON.parse(PATH_JSON)
    serialized.background = "green"
    serialized.backgroundImage = JSON.parse(
      '{"type":"image","originX":"left","originY":"top","left":13.6,"top":-1.4,"width":3000,"height":3351,"fill":"rgb(0,0,0)","stroke":null,"strokeWidth":0,"strokeDashArray":null,"strokeLineCap":"butt","strokeDashOffset":0,"strokeLineJoin":"miter","strokeMiterLimit":4,"scaleX":0.05,"scaleY":0.05,"angle":0,"flipX":false,"flipY":false,"opacity":1,"shadow":null,"visible":true,"backgroundColor":"","fillRule":"nonzero","globalCompositeOperation":"source-over","skewX":0,"skewY":0,"src":"' +
        IMG_SRC +
        '","filters":[],"crossOrigin":""}'
    )
    canvas.loadFromJSON(serialized, function () {
      expect(!canvas.isEmpty()).toBeTruthy()
      expect(canvas.backgroundColor).toEqual("green")
      expect(canvas.backgroundImage instanceof fabric.Image).toBeTruthy()
      done()
    })
  })

  test("loadFromJSON custom properties", function (done) {
    var rect = new fabric.Rect({ width: 10, height: 20 })
    rect.padding = 123
    rect.foo = "bar"

    canvas.add(rect)

    var jsonWithoutFoo = JSON.stringify(canvas.toJSON(["padding"]))
    var jsonWithFoo = JSON.stringify(canvas.toJSON(["padding", "foo"]))

    expect(jsonWithFoo).toEqual(RECT_JSON_WITH_PADDING)
    expect(jsonWithoutFoo !== RECT_JSON_WITH_PADDING).toBeTruthy()

    canvas.clear()
    canvas.loadFromJSON(jsonWithFoo, function () {
      var obj = canvas.item(0)

      expect(obj.padding).toEqual(123)
      expect(obj.foo).toEqual("bar")
      done()
    })
  })

  test("loadFromJSON with text", function (done) {
    var json =
      '{"objects":[{"type":"text","left":150,"top":200,"width":128,"height":64.32,"fill":"#000000","stroke":"","strokeWidth":"","scaleX":0.8,"scaleY":0.8,"angle":0,"flipX":false,"flipY":false,"opacity":1,"text":"NAME HERE","fontSize":24,"fontWeight":"","fontFamily":"Delicious_500","fontStyle":"","lineHeight":"","textDecoration":"","textAlign":"center","path":"","strokeStyle":"","backgroundColor":""}],"background":"#ffffff"}'
    canvas.loadFromJSON(json, function () {
      canvas.renderAll()

      expect("text").toEqual(canvas.item(0).type)
      expect(150).toEqual(canvas.item(0).left)
      expect(200).toEqual(canvas.item(0).top)
      expect("NAME HERE").toEqual(canvas.item(0).text)

      done()
    })
  })

  test("loadFromJSON with clipPath", function (done) {
    var json =
      '{"clipPath": {"type":"text","left":150,"top":200,"width":128,"height":64.32,"fill":"#000000","stroke":"","strokeWidth":"","scaleX":0.8,"scaleY":0.8,"angle":0,"flipX":false,"flipY":false,"opacity":1,"text":"NAME HERE","fontSize":24,"fontWeight":"","fontFamily":"Delicious_500","fontStyle":"","lineHeight":"","textDecoration":"","textAlign":"center","path":"","strokeStyle":"","backgroundColor":""}}'
    canvas.loadFromJSON(json, function () {
      canvas.renderAll()
      expect("text").toEqual(canvas.clipPath.type)
      done()
    })
  })

  test("sendToBack", function () {
    expect(typeof canvas.sendToBack === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()

    canvas.add(rect1, rect2, rect3)

    canvas.sendToBack(rect3)
    expect(canvas.item(0)).toEqual(rect3)

    canvas.sendToBack(rect2)
    expect(canvas.item(0)).toEqual(rect2)

    canvas.sendToBack(rect2)
    expect(canvas.item(0)).toEqual(rect2)
  })

  test("bringToFront", function () {
    expect(typeof canvas.bringToFront === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()

    canvas.add(rect1, rect2, rect3)

    canvas.bringToFront(rect1)
    expect(canvas.item(2)).toEqual(rect1)

    canvas.bringToFront(rect2)
    expect(canvas.item(2)).toEqual(rect2)

    canvas.bringToFront(rect2)
    expect(canvas.item(2)).toEqual(rect2)
  })

  test("sendBackwards", function () {
    expect(typeof canvas.sendBackwards === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()

    canvas.add(rect1, rect2, rect3)

    // [ 1, 2, 3 ]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.sendBackwards(rect3)

    // moved 3 one level back — [1, 3, 2]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)

    canvas.sendBackwards(rect3)

    // moved 3 one level back — [3, 1, 2]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(0)).toEqual(rect3)

    canvas.sendBackwards(rect3)

    // 3 stays at the deepEqual position — [2, 3, 1]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(0)).toEqual(rect3)

    canvas.sendBackwards(rect2)

    expect(canvas.item(2)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(0)).toEqual(rect3)

    canvas.sendBackwards(rect2)

    expect(canvas.item(2)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)
  })

  test("bringForward", function () {
    expect(typeof canvas.bringForward === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()

    canvas.add(rect1, rect2, rect3)

    // initial position — [ 1, 2, 3 ]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.bringForward(rect1)

    // 1 moves one way up — [ 2, 1, 3 ]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.bringForward(rect1)

    // 1 moves one way up again — [ 2, 3, 1 ]
    expect(canvas.item(2)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)

    canvas.bringForward(rect1)

    // 1 is already all the way on top and so doesn't change position — [ 2, 3, 1 ]
    expect(canvas.item(2)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)

    canvas.bringForward(rect3)

    // 1 is already all the way on top and so doesn't change position — [ 2, 1, 3 ]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)
  })

  test("moveTo", function () {
    expect(typeof canvas.moveTo === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect(),
      rect3 = makeRect()

    canvas.add(rect1, rect2, rect3)

    // [ 1, 2, 3 ]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.moveTo(rect3, 0)

    // moved 3 to level 0 — [3, 1, 2]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(0)).toEqual(rect3)

    canvas.moveTo(rect3, 1)

    // moved 3 to level 1 — [1, 3, 2]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)

    canvas.moveTo(rect3, 2)

    // moved 3 to level 2 — [1, 2, 3]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.moveTo(rect3, 2)

    // moved 3 to same level 2 and so doesn't change position — [1, 2, 3]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.moveTo(rect2, 0)

    // moved 2 to level 0 — [2, 1, 3]
    expect(canvas.item(1)).toEqual(rect1)
    expect(canvas.item(0)).toEqual(rect2)
    expect(canvas.item(2)).toEqual(rect3)

    canvas.moveTo(rect2, 2)

    // moved 2 to level 2 — [1, 3, 2]
    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(2)).toEqual(rect2)
    expect(canvas.item(1)).toEqual(rect3)
  })

  test("item", function () {
    expect(typeof canvas.item === "function").toBeTruthy()

    var rect1 = makeRect(),
      rect2 = makeRect()

    canvas.add(rect1, rect2)

    expect(canvas.item(0)).toEqual(rect1)
    expect(canvas.item(1)).toEqual(rect2)

    canvas.remove(canvas.item(0))

    expect(canvas.item(0)).toEqual(rect2)
  })

  test("complexity", function () {
    expect(typeof canvas.complexity === "function").toBeTruthy()
    expect(canvas.complexity()).toEqual(0)

    canvas.add(makeRect())
    expect(canvas.complexity()).toEqual(1)

    canvas.add(makeRect(), makeRect())
    expect(canvas.complexity()).toEqual(3)
  })

  test("toString", function () {
    expect(typeof canvas.toString === "function").toBeTruthy()

    expect(canvas.toString()).toEqual("#<fabric.Canvas (0): { objects: 0 }>")

    canvas.add(makeRect())
    expect(canvas.toString()).toEqual("#<fabric.Canvas (1): { objects: 1 }>")
  })

  test("dispose clear references", function () {
    var canvas2 = new fabric.StaticCanvas(null, { renderOnAddRemove: false })
    expect(typeof canvas2.dispose === "function").toBeTruthy()
    canvas2.add(makeRect(), makeRect(), makeRect())
    canvas2.dispose()
    expect(canvas2.getObjects().length).toEqual(0)
    // original is qunit equal(null)
    expect(canvas2.lowerCanvasEl).toEqual(undefined)
    expect(canvas2.contextContainer).toEqual(null)
  })

  test("clone", function () {
    expect(typeof canvas.clone === "function").toBeTruthy()
    // TODO (kangax): test clone
  })

  test("getSetWidth", function () {
    expect(typeof canvas.getWidth === "function").toBeTruthy()
    expect(canvas.getWidth()).toEqual(200)
    expect(canvas.setWidth(444)).toEqual(canvas)
    expect(canvas.getWidth()).toEqual(444)
    expect(canvas.lowerCanvasEl.style.width).toEqual(444 + "px")
  })

  test("getSetHeight", function () {
    expect(typeof canvas.getHeight === "function").toBeTruthy()
    expect(canvas.getHeight()).toEqual(200)
    expect(canvas.setHeight(765)).toEqual(canvas)
    expect(canvas.getHeight()).toEqual(765)
    expect(canvas.lowerCanvasEl.style.height).toEqual(765 + "px")
  })

  test("setWidth css only", function () {
    canvas.setWidth(123)
    canvas.setWidth("100%", { cssOnly: true })

    expect(canvas.lowerCanvasEl.style.width).toEqual("100%")
    expect(canvas.getWidth()).toEqual(123)
  })

  test("setHeight css only", function () {
    canvas.setHeight(123)
    canvas.setHeight("100%", { cssOnly: true })

    expect(canvas.lowerCanvasEl.style.height).toEqual("100%")
    expect(canvas.getHeight()).toEqual(123)
  })

  test("setDimensions css only", function () {
    canvas.setDimensions({ width: 200, height: 200 })
    canvas.setDimensions({ width: "250px", height: "350px" }, { cssOnly: true })
    expect(canvas.lowerCanvasEl.style.width).toEqual("250px")
    expect(canvas.lowerCanvasEl.style.height).toEqual("350px")
    expect(canvas.getWidth()).toEqual(200)
    expect(canvas.getHeight()).toEqual(200)
  })

  test("setWidth backstore only", function () {
    canvas.setWidth(123)
    canvas.setWidth(500, { backstoreOnly: true })

    expect(canvas.lowerCanvasEl.style.width).toEqual(123 + "px")
    expect(canvas.getWidth()).toEqual(500)
  })

  test("setHeight backstore only", function () {
    canvas.setHeight(123)
    canvas.setHeight(500, { backstoreOnly: true })

    expect(canvas.lowerCanvasEl.style.height).toEqual(123 + "px")
    expect(canvas.getHeight()).toEqual(500)
  })

  test("setDimensions backstore only", function () {
    canvas.setDimensions({ width: 200, height: 200 })
    canvas.setDimensions({ width: 250, height: 350 }, { backstoreOnly: true })
    expect(canvas.lowerCanvasEl.style.width).toEqual(200 + "px")
    expect(canvas.lowerCanvasEl.style.height).toEqual(200 + "px")
    expect(canvas.getWidth()).toEqual(250)
    expect(canvas.getHeight()).toEqual(350)
    canvas.cancelRequestedRender()
  })

  test("fxRemove", function (done) {
    expect(typeof canvas.fxRemove === "function").toBeTruthy()

    var rect = new fabric.Rect()
    canvas.add(rect)

    var callbackFired = false
    function onComplete() {
      callbackFired = true
      expect(canvas.item(0)).toEqual(undefined)
      expect(callbackFired).toBeTruthy()
      canvas.cancelRequestedRender()
      done()
    }

    expect(canvas.item(0) === rect).toBeTruthy()
    expect(canvas.fxRemove(rect, { onComplete: onComplete })).toEqual(canvas)
  })

  test("options in setBackgroundImage from URL", function (done) {
    canvas.setBackgroundImage(
      IMG_SRC,
      function () {
        expect(canvas.backgroundImage.canvas).toEqual(canvas)
        expect(canvas.backgroundImage.left).toEqual(50)
        expect(canvas.backgroundImage.originX).toEqual("right")
        done()
      },
      {
        left: 50,
        originX: "right"
      }
    )
  })

  test("options in setOverlayImage from URL", function (done) {
    canvas.setOverlayImage(
      IMG_SRC,
      function () {
        expect(canvas.overlayImage.canvas).toEqual(canvas)
        expect(canvas.overlayImage.left).toEqual(50)
        expect(canvas.overlayImage.originX).toEqual("right")
        done()
      },
      {
        left: 50,
        originX: "right"
      }
    )
  })

  test("setViewportTransform", function () {
    expect(typeof canvas.setViewportTransform === "function").toBeTruthy()
    var vpt = [2, 0, 0, 2, 50, 50]
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, 0, 0])
    canvas.setViewportTransform(vpt)
    expect(canvas.viewportTransform).toEqual(vpt)
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("getZoom", function () {
    expect(typeof canvas.getZoom === "function").toBeTruthy()
    var vpt = [2, 0, 0, 2, 50, 50]
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
    expect(canvas.getZoom()).toEqual(1)
    canvas.setViewportTransform(vpt)
    expect(canvas.getZoom()).toEqual(2)
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("setZoom", function () {
    expect(typeof canvas.setZoom === "function").toBeTruthy()
    expect(canvas.getZoom()).toEqual(1)
    canvas.setZoom(2)
    expect(canvas.getZoom()).toEqual(2)
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("zoomToPoint", function () {
    expect(typeof canvas.zoomToPoint === "function").toBeTruthy()
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, 0, 0])
    var point = new fabric.Point(50, 50)
    canvas.zoomToPoint(point, 1)
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, 0, 0])
    canvas.zoomToPoint(point, 2)
    expect(canvas.viewportTransform).toEqual([2, 0, 0, 2, -50, -50])
    canvas.zoomToPoint(point, 3)
    expect(canvas.viewportTransform).toEqual([3, 0, 0, 3, -100, -100])
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("absolutePan", function () {
    expect(typeof canvas.absolutePan === "function").toBeTruthy()
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, 0, 0])
    var point = new fabric.Point(50, 50)
    canvas.absolutePan(point)
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, -point.x, -point.y])
    canvas.absolutePan(point)
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, -point.x, -point.y])
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("relativePan", function () {
    expect(typeof canvas.relativePan === "function").toBeTruthy()
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, 0, 0])
    var point = new fabric.Point(-50, -50)
    canvas.relativePan(point)
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, -50, -50])
    canvas.relativePan(point)
    expect(canvas.viewportTransform).toEqual([1, 0, 0, 1, -100, -100])
    canvas.viewportTransform = fabric.StaticCanvas.prototype.viewportTransform
  })

  test("getContext", function () {
    expect(typeof canvas.getContext === "function").toBeTruthy()
    var context = canvas.getContext()
    expect(context).toEqual(canvas.contextContainer)
  })

  test("calcViewportBoundaries", function () {
    expect(typeof canvas.calcViewportBoundaries === "function").toBeTruthy()
    canvas.calcViewportBoundaries()
    expect(canvas.vptCoords.tl).toEqual(new fabric.Point(0, 0))
    expect(canvas.vptCoords.tr).toEqual(new fabric.Point(canvas.getWidth(), 0))
    expect(canvas.vptCoords.bl).toEqual(new fabric.Point(0, canvas.getHeight()))
    expect(canvas.vptCoords.br).toEqual(
      new fabric.Point(canvas.getWidth(), canvas.getHeight())
    )
  })

  test("calcViewportBoundaries with zoom", function () {
    expect(typeof canvas.calcViewportBoundaries === "function").toBeTruthy()
    canvas.setViewportTransform([2, 0, 0, 2, 0, 0])
    expect(canvas.vptCoords.tl).toEqual(new fabric.Point(0, 0))
    expect(canvas.vptCoords.tr).toEqual(
      new fabric.Point(canvas.getWidth() / 2, 0)
    )
    expect(canvas.vptCoords.bl).toEqual(
      new fabric.Point(0, canvas.getHeight() / 2)
    )
    expect(canvas.vptCoords.br).toEqual(
      new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2)
    )
  })

  test("calcViewportBoundaries with zoom and translation", function () {
    expect(typeof canvas.calcViewportBoundaries === "function").toBeTruthy()
    canvas.setViewportTransform([2, 0, 0, 2, -60, 60])
    expect(canvas.vptCoords.tl).toEqual(new fabric.Point(30, -30))
    expect(canvas.vptCoords.tr).toEqual(
      new fabric.Point(30 + canvas.getWidth() / 2, -30)
    )
    expect(canvas.vptCoords.bl).toEqual(
      new fabric.Point(30, canvas.getHeight() / 2 - 30)
    )
    expect(canvas.vptCoords.br).toEqual(
      new fabric.Point(30 + canvas.getWidth() / 2, canvas.getHeight() / 2 - 30)
    )
  })

  test("_isRetinaScaling", function () {
    canvas.enableRetinaScaling = true
    fabric.devicePixelRatio = 2
    var isScaling = canvas._isRetinaScaling()
    expect(isScaling).toEqual(true)

    canvas.enableRetinaScaling = false
    fabric.devicePixelRatio = 2
    var isScaling = canvas._isRetinaScaling()
    expect(isScaling).toEqual(false)

    canvas.enableRetinaScaling = false
    fabric.devicePixelRatio = 1
    var isScaling = canvas._isRetinaScaling()
    expect(isScaling).toEqual(false)

    canvas.enableRetinaScaling = true
    fabric.devicePixelRatio = 1
    var isScaling = canvas._isRetinaScaling()
    expect(isScaling).toEqual(false)
  })

  test("getRetinaScaling", function () {
    canvas.enableRetinaScaling = true
    fabric.devicePixelRatio = 1
    var scaling = canvas.getRetinaScaling()
    expect(scaling).toEqual(1)

    fabric.devicePixelRatio = 2
    var scaling = canvas.getRetinaScaling()
    expect(scaling).toEqual(2)

    fabric.devicePixelRatio = 2
    canvas.enableRetinaScaling = false
    var scaling = canvas.getRetinaScaling()
    expect(scaling).toEqual(1)
  })

  test("options in setBackgroundImage from image instance", function (done) {
    createImageObject(function (imageInstance) {
      canvas.setBackgroundImage(
        imageInstance,
        function () {
          expect(canvas.backgroundImage.canvas).toEqual(canvas)
          expect(canvas.backgroundImage.left).toEqual(100)
          expect(canvas.backgroundImage.originX).toEqual("center")

          done()
        },
        {
          left: 100,
          originX: "center"
        }
      )
    })
  })

  test("options in setOverlayImage from image instance", function (done) {
    createImageObject(function (imageInstance) {
      canvas.setOverlayImage(
        imageInstance,
        function () {
          expect(canvas.overlayImage).toEqual(imageInstance)
          expect(imageInstance.left).toEqual(100)
          expect(imageInstance.originX).toEqual("center")
          expect(imageInstance.canvas).toEqual(canvas)
          done()
        },
        {
          left: 100,
          originX: "center"
        }
      )
    })
  })

  test("createPNGStream", function () {
    if (!fabric.isLikelyNode) {
      expect(true).toBeTruthy()
    } else {
      expect(typeof canvas.createPNGStream === "function").toBeTruthy()
    }
  })

  test("createJPEGStream", function () {
    if (!fabric.isLikelyNode) {
      expect(true).toBeTruthy()
    } else {
      expect(typeof canvas.createJPEGStream === "function").toBeTruthy()
    }
  })

  test("toSVG with background", function () {
    var canvas2 = new fabric.StaticCanvas()
    canvas2.backgroundColor = "red"
    var svg = canvas2.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="300" height="150" viewBox="0 0 300 150" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n</defs>\n<rect x="0" y="0" width="100%" height="100%" fill="red"></rect>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("toSVG with background and zoom and svgViewportTransformation", function () {
    var canvas2 = new fabric.StaticCanvas()
    canvas2.backgroundColor = "blue"
    canvas2.svgViewportTransformation = true
    canvas2.viewportTransform = [3, 0, 0, 3, 60, 30]
    var svg = canvas2.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="300" height="150" viewBox="-20 -10 100 50" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n</defs>\n<rect x="0" y="0" width="100%" height="100%" fill="blue"></rect>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("toSVG with background gradient", function () {
    fabric.Object.__uid = 0
    var canvas2 = new fabric.StaticCanvas()
    canvas2.backgroundColor = new fabric.Gradient({
      type: "linear",
      colorStops: [
        { offset: 0, color: "black" },
        { offset: 1, color: "white" }
      ],
      coords: {
        x1: 0,
        x2: 300,
        y1: 0,
        y2: 0
      }
    })
    var svg = canvas2.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="300" height="150" viewBox="0 0 300 150" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n<linearGradient id="SVGID_0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(1 0 0 1 0 0) matrix(1 0 0 1 -150 -75)"  x1="0" y1="0" x2="300" y2="0">\n<stop offset="0%" style="stop-color:black;"/>\n<stop offset="100%" style="stop-color:white;"/>\n</linearGradient>\n</defs>\n<rect transform="matrix(1 0 0 1 0 0) translate(150,75)" x="-150" y="-75" width="300" height="150" fill="url(#SVGID_0)"></rect>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("toSVG with background gradient and transforms", function () {
    fabric.Object.__uid = 0
    var canvas2 = new fabric.StaticCanvas()
    canvas2.viewportTransform = [1, 2, 3, 4, 5, 6]
    canvas2.backgroundColor = new fabric.Gradient({
      type: "linear",
      gradientTransform: [0.2, 0.3, 0.4, 0.5, -3, -5],
      colorStops: [
        { offset: 0, color: "black" },
        { offset: 1, color: "white" }
      ],
      coords: {
        x1: 0,
        x2: 300,
        y1: 0,
        y2: 0
      }
    })
    var svg = canvas2.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="300" height="150" viewBox="-5 -1.5 300 37.5" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n<linearGradient id="SVGID_0" gradientUnits="userSpaceOnUse" gradientTransform="matrix(1 2 3 4 5 6) matrix(0.2 0.3 0.4 0.5 -153 -23.75)"  x1="0" y1="0" x2="300" y2="0">\n<stop offset="0%" style="stop-color:black;"/>\n<stop offset="100%" style="stop-color:white;"/>\n</linearGradient>\n</defs>\n<rect transform="matrix(-2 1 1.5 -0.5 1 -2) translate(150,75)" x="-150" y="-75" width="300" height="150" fill="url(#SVGID_0)"></rect>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("toSVG with background pattern", function () {
    fabric.Object.__uid = 0
    var canvas2 = new fabric.StaticCanvas()
    canvas2.backgroundColor = new fabric.Pattern({
      source: "a.jpeg",
      repeat: "repeat"
    })
    var svg = canvas2.toSVG()
    var expectedSVG =
      '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="300" height="150" viewBox="0 0 300 150" xml:space="preserve">\n<desc>Created with Fabric.js ' +
      fabric.version +
      '</desc>\n<defs>\n<pattern id="SVGID_0" x="0" y="0" width="0" height="0">\n<image x="0" y="0" width="0" height="0" xlink:href=""></image>\n</pattern>\n</defs>\n<rect transform="matrix(1 0 0 1 0 0) translate(150,75)" x="-150" y="-75" width="300" height="150" fill="url(#SVGID_0)"></rect>\n</svg>'
    expect(svg).toEqual(expectedSVG)
  })

  test("requestRenderAll and cancelRequestedRender", function () {
    var canvas2 = new fabric.StaticCanvas()
    expect(canvas2.isRendering).toEqual(undefined)
    canvas2.requestRenderAll()
    expect(canvas2.isRendering).not.toBe(0)
    canvas2.cancelRequestedRender()
    expect(canvas2.isRendering).toEqual(0)
  })

  // test('backgroundImage', function(done) {
  //   ;
  //   done.deepEqual('', canvas.backgroundImage);
  //   canvas.setBackgroundImage('../../assets/pug.jpg');

  //   setTimeout(function() {

  //     done.ok(typeof canvas.backgroundImage == 'object');
  //     done.ok(/pug\.jpg$/.test(canvas.backgroundImage.src));

  //     done();
  //   }, 1000);
  // });

  // test('setOverlayImage', function(done) {
  //   ;
  //   done.deepEqual(canvas.overlayImage, undefined);
  //   canvas.setOverlayImage('../../assets/pug.jpg');

  //   setTimeout(function() {

  //     done.ok(typeof canvas.overlayImage == 'object');
  //     done.ok(/pug\.jpg$/.test(canvas.overlayImage.src));

  //     done();
  //   }, 1000);
  // });
})
